# 競技プログラミングで使うアルゴリズム

## 目次
1. [アルゴリズム一覧](#algorithm_all)
2. [各アルゴリズムについて](#each_algorithm)
    * [探索アルゴリズム](#Search)
        * [全探索]
        * [二分探索](#Binary_Search)
        * [DFS](#DFS)
        * [BFS](#BFS)
        * [bit全探索](#bit_all_search)
        * [三分探索]
        * [貪欲法]
        * [半分全列挙]
    * [グラフアルゴリズム](#Graph)  
        * [動的計画法(DP)]  
        * [(桁、区間、bit)DP]  
        * [ベルマン・フォード法]  
        * [ダイクストラ法]  
        * [ワーシャルフロイド法]  
        * [クラスカル法]
        * [最小カット]
        * [最大流]
        * [二部グラフ判定]
        * [二部マッチング]
    * [整数アルゴリズム](#Integer)
        * [GCD,LCM]
        * [約数列挙]
        * [エラトステネスの篩]
        * [高速な素数判定法]
        * [逆元を計算する手法]
        * [冪乗を高速に計算する手法]
        * [Grundy数]
        * [行列累乗]
    * [文字列アルゴリズム](#String)
    * [その他のアルゴリズム](#Others)
    * [データ構造](#Data)


<!--
**太字**
*斜字*
~~削除します~~
***
-->

<br/>

***

<br/>


<a id="algorithm_all"></a>
# 1.アルゴリズム一覧 

<br/>

* ### 探索アルゴリズム
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**全探索**|**二分探索**|**深さ優先探索(DFS)**|**幅優先探索(BFS)**|
|**bit全探索**|**三分探索(黄金探索)**|**貪欲法**|**半分全列挙**|

<br/>

* ### グラフアルゴリズム
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**動的計画法(DP)**|**（桁、区間、bit）dp**|**ベルマン・フォード法**|**ダイクストラ法**|
|**ワーシャルフロイド法**|**クラスカル法**|**最小カット**|**最大流**|
|**二部グラフ判定**|**二部マッチング**|

<br/>

* ### 整数アルゴリズム
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**GCD, LCM**|**約数列挙**|**エラトステネスの篩**|**高速な素数判定法**|
|**逆元を計算する手法**|**冪乗を高速に計算する手法**|**Grundy数**|**行列累乗**|

<br/>

* ### 文字列アルゴリズム
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**回文判定**|**LCS**|**ランレングス圧縮**|**Rolling Hash**|

<br/>

* ### その他のアルゴリズム
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**ゼータ変換・メビウス変換**|**平方分割**|**論理演算**|**いもす法**|
|**座標圧縮**|**累積和**|**包除原理**|**区間スケジューリング**|
|**尺取り法**|**累積和**|**ダブリング**|

<br/>

* ### データ構造
<!--左詰めで記述-->
|||||
|:---|:---|:---|:---|
|**グラフ**|**木**|**Union-Find**|**セグメント木**|
|**BIT(Binary Indexed Tree)**|

***

<br/>

<!--
* 箇条書き1
  * 箇条書き3
    * 箇条書き5
* 箇条書き7
    * 箇条書き8

1. 数字付き1
2. 数字付き2
3. 数字付き3

> 引用
>> 二重引用
>
> 二重引用あとは一つ行空けた方が良いみたい
>


改行するときはスペース2つ入れる↓

【拡張機能：HTMLやPDFに変換】  
http://www.atmarkit.co.jp/ait/articles/1804/27/news034.html

[リンク⇒拡張機能：HTMLやPDFに変換](http://www.atmarkit.co.jp/ait/articles/1804/27/news034.html)

-->

***
<a id="each_algorithm"></a>
# **各アルゴリズムについて**

<a id="Search"></a>
# 探索アルゴリズム

<a id="Binary_Search"></a>
## 二分探索
「二分探索」とは「**$n$個の要素からなるソート済み配列から目的の値を高速に探索するアルゴリズム**」である。具体的には、単純な線形探索では計算量が$O(n)$であるのに対して、二分探索では計算量が$O$(log $n$)となる。

ここでは「めぐる式二分探索法」について解説する。

【C++】
```c++
// 解が存在するときの条件を問題ごとに定義する
bool isOK(int key) {
    // if ( ?? >= key) return true;
    // else return false;
}

// 二分探索を行う
// ok: 解が存在する値, ng: 解が存在しない値
int meguru_binary_search(int ng, int ok, int key) {
    // okとngのどちらが大きいかわからないことを考慮した処理
    while (abs(ok - ng) > 1) {
        int mid = (ok + ng) / 2;
        if (isOK(mid, key)) ok = mid;
        else ng = mid;
    }
    return ok;
}
```

【Python】
```python
# 解が存在するときの条件を問題ごとに定義する
# bool値で返す
def is_ok(key):
    pass

# 二分探索を行う
# ok: 解が存在する値, ng: 解が存在しない値
def meguru_bisect(ng, ok):
    # okとngのどちらが大きいかわからないことを考慮した処理
    while(abs(ok-ng) > 1):
        mid = (ok + ng) // 2
        if is_ok(mid):
            ok = mid
        else:
            ng = mid
    return ok
```


<a id="DFS"></a>
## DFS(深さ優先探索) 
【C++】
1. s-tパスについて

```c++
// コメント
#include <iostream>
using namespace std;

int main(void){
    cout << "Hello World" << endl
}
```
<a id="BFS"></a>
## BFS(深さ優先探索)
1. $s$-$t$パスについて


<a id="bit_all_search"></a>
## bit全探索

【Python】  
「ビットシフト演算」を用いる。

1. **全パターン数を得る**  
   「左シフト`<<`」を用いて`1 << n`と記述することで「2のn乗」を表現できる。  
   例えば`1 << 3`は10進数の`8`を表す。(`2**3`と同じ)

2. **i番目が`1`か`0`かを確認する**  
   「右シフト`>>`」を用いて`(bit >> i) & 1`と記述することで「`i`桁目が1なら1、0なら0」と表現できる。  
   例えば`6 >> 1`は「`110`から1桁右にずらし`11`となり10進数で`3`」となる。`(6 >> 1) & 1`で`11 & 1`を計算する。このとき`11 & 01`と足りない部分が`0`で埋められ`11 & 1 = 01 = 1`となる。  
   ゆえに、`6`の`1`桁目は`1`であることが確認できた。

``` python
for bit in range(1 << n):
    for i in range(n):
        if (bit >> i) & 1:
            # 1のときの処理
        else:
            # 0のときの処理
```

<a id="Graph"></a>
# グラフアルゴリズム

## ベルマンフォード法
ベルマンフォード法は「負辺を含む有向グラフにおいて2頂点間の最短経路長を求めるアルゴリズム」である。

<a id="Integer"></a>
# 整数アルゴリズム

## GCD, LCM
GCD(Greatest Common Divisor)は**最大公約数**のことを、LCM(Least Common Multiple)は**最小公倍数**のことを指す。
1. 最大公約数  
2つの整数$A,B$の共通の約数を$A,B$の公約数と呼ぶ。また公約数の中で最も大きいものを最大公約数と呼ぶ。そのため、整数$A,B$の公約数は必ず$A,B$の最大公約数の約数となっている。
2. 最小公倍数  
2つの整数$A,B$の共通の倍数を$A,B$の公倍数と呼ぶ。また公倍数の中で最も小さいものを最小公倍数と呼ぶ。そのため、整数$A,B$の公倍数は必ず$A,B$の最小公倍数の倍数となっている。

$N$個の整数$A_0,A_1,...,A_{N-1}$に対して最大公約数をとるとき$GCD(A_0,A_1,...,A_{N-1})$と書き、最小公倍数をとるとき$LCM(A_0,A_1,...,A_{N-1})$と書ける。
また次のことが成り立つため、$N$個の最大公約数・最小公倍数を求めたい場合でも2つずつ順に求めていけばよい。
> $GCD(A,B,C) = GCD(GCD(A,B),C)$
$LCM(A,B,C) = LCM(LCM(A,B),C)$

最大公約数の実装には「素因数分解を用いる方法」と「ユークリッドの互除法を用いる方法」の2つがあるが、ここでは「ユークリッドの互除法」を用いて実装を行う。
* ユークリッドの互除法
ユークリッドの互除法は「2つの整数$A,B$の最大公約数$GCD(A,B)$を求めるアルゴリズム」である。具体的には以下のようなステップで進めます。
1. $A$を$B$で割ったあまりを$R$とする(ただし$A \geq B$とする)
2. $R=0$であれば$B$が求める最大公約数である。$R≠0$のときは$A←B$に$B←R$に置き換えてステップ1に戻る。
> 例えば$42$と$28$の最大公約数は以下のように求められる。  
$42÷28=1...14$  
$28÷14=2...0$  
よって最大公約数は$14$と求まる。

ここで最大公約数と最小公倍数には以下の関係が成り立つ。
> 2つの正の整数$A,B$の最大公約数を$G$、最小公倍数を$L$としたとき$AB = GL$が成立する。

そのため**最小公倍数は$\frac{AB}{GCD(A,B)}$で求めることができる。**

計算量は$A \geq B \geq 0$としたとき$O(log B)$となる。

【C++】
```c++
#include <iostream>
using namespace std;

// 整数A,Bの最大公約数を返す
long long GCD(long long A, long long B) {
    if(B == 0) return A;
    else return GCD(B, A % B);
}

// 整数A,Bの最小公倍数を返す
long long LCM(long long A, long long B) {
    // A*Bのオーバーフローに注意して実装
    return A / GCD(A,B) * B;
}

```
【Python】
```python
# 整数A,Bの最大公約数を返す
def GCD(A,B):
    if B == 0:
        return A
    else:
        return GCD(B, A % B)

# 整数A,Bの最小公倍数を返す
def LCM(A,B):
    return A // GCD(A,B) * B
```

## 約数列挙



## エラトステネスの篩
エラトステネスの篩(ふるい)とは「**与えられた整数$N$以下の素数を全て求める**」ためのアルゴリズムである。具体的には「**$N$以下の整数の集合から合成数を次々とふるいとしていき、最終的に素数のみを残す**」方法をとる。  
計算量は$O(N$ $loglog$ $N)$である。   

【C++】
```c++
#include <iostream>
#include <vector>
using namespace std;

// 1以上N以下の整数が素数かどうかを配列(vector)で返す
// 使用例: vector<bool> isprime = Eratosthenes(N)
// isprime[i] = trueなら「整数iは素数」、falseなら「整数iは素数ではない」
vector<bool> Eratosthenes (int N) {
    // 1~Nの素数判定を格納するテーブル
    vector<bool> isprime(N+1, true);
    // 0と1は素数ではない
    isprime[0] = isprime[1] = false;
    // ふるいにかけていく

    for(int p = 2; p <= N; p++) {
        // すでに合成数と分かったものはスキップ
        if(!isprime[p]) continue;
        // p以外のpの倍数は素数ではない
        for(int q = p*2; q <= N; q += p) {
            isprime[q] = false;
        }
    }
    return isprime;
}
```
【Python】
```python
# 1以上N以下の整数が素数かどうかを配列(list)で返す
# 使用例: isprime = Eratosthenes(N)
# isprime[i] = trueなら「整数iは素数」、falseなら「整数iは素数ではない」
def Eratosthenes(N):
    # 1~Nの素数判定を格納するテーブル
    isprime = [True] * (N+1)
    # 0と1は素数ではない
    isprime[0], isprime[1] = False, False

    # ふるいにかけていく
    for p in range(2, N+1):
        # すでに合成数と分かったものはスキップ
        if not isprime[p]:
            continue
        # p以外のpの倍数は素数ではない
        q = 2*p
        while q <= N:
            isprime[q] = False
            q += p
    
    return isprime
```

## 高速な素数判定法
「**与えられた整数$N$が素数かどうかを判定する**」という素数判定問題について考える。　　

1. $O(N)$の解法  
最も単純な解法は「$i=2,3,...,N-1$に対して$N÷i$が割り切れないことを示す」である。
2. **$O(√N)$の解法**  
1.で示した解法を少し改善すると「**$i=2,3,...,√N$に対して$N÷i$が割り切れないことを示す**」で表現ができる。証明と実装コードを以下に示した。  
<証明>  
$N$が素数でないとき、$N = a \times b$と表せる。  
ここで、仮に$N$が$a>√N$で初めて割り切れたとすると$b=\frac{N}{a} < √N$となり矛盾する。  
ゆえに「$N$が素数でないならば必ず$i=2,3,...,√N$で割り切ることができる」ことが示された。  
<証明終わり>  

【C++】
```c++
#include <iostream>
using namespace std;

// 素数を判定する関数
// 素数 = true, 素数でない = false を返す
bool isprime(long long N) {
    if(N < 2) return false; // 0と1は素数ではない
    for(long long i = 2; i*i <= N; i++) {
        if(N % i == 0) return false;
    }
    return true;
}
```
【Python】
```python
# 素数を判定する関数
# 素数 = True, 素数でない = False を返す
def isprime(N):
    if N < 2:
        return False # 0と1は素数ではない
    i = 2
    while i*i <= N:
        if N % i == 0:
            return False # 割り切れるなら素数ではない
        i += 1
    return True
```
ここでは「決定的素数判定法」(確実に誤りがない)について述べた。「確率的素数判定法」(誤りが出る可能性もあるが、判定速度がより高速)には「ミラー-ラビン素数判定法」などがある。

<a id="String"></a>
# 文字列アルゴリズム

<a id="Others"></a>
# その他のアルゴリズム

## Grundy数
Grundy数とは不偏ゲームに対して定義することのできる「ゲームの状態を表す数」の一つである。
* **Grundy数=0なら負け**
* **Grudny数>0なら勝ち**

という定義をしておくことで、Grundy数を求めることができればどちらが必勝なのかを判別することができる。

1. Mex関数  
Grundy数の説明の前に、Mex(Minumum excludant)について説明する。
mex関数は「集合に含まれない最も小さな非負整数を返す関数」である。  
* mex関数の例について
> $mex({0}) = 1$  
$mex({0,1}) = 2$  
$mex({0,2,3}) = 1$  
$mex({1,2}) = 0$  
$mex({}) = 0$

2. Grundy数  
あるゲームの局面を「その局面から1手で推移可能な局面のGrundy数のmex」として定める。
Grundy数には二つの利点がある。
* 必ず「0の局面」から「0の局面」に遷移は不可能であり、必ず「1の局面」から「0の局面」に遷移させることが可能。
* Grundy数同士はXOR演算を使って合成できる。
> Nimでコインの山が2つあり$(2,1)$枚のとき

||||||||
|:---|:---|:---|:---|:---|:---|:---|
|コインの枚数 (n,n)|(0,0)|(1,0)|(2,0)|(0,1)|(1,1)|(2,1)|
|Grundy数 g(n,n)|0|1|2|1|0|3|

> Grundy数の計算は以下のように行う。  
$g(0,0) =$ 終了状態であるため$0$  
$g(1,0) = mex({g(0,0)}) = mex({0}) = 1$  
$g(2,0) = mex({g(1,0), g(0,0)}) = mex({0,1}) = 2$  
$g(3,0) = mex({g(2,0), g(1,0), g(0,0)}) = mex({0,1,2}) = 3$  
$g(0,1) = mex({g(0,0)}) = mex({0}) = 1$  
$g(1,1) = mex({g(1,0), g(0,1)}) = mex({1}) = 0$  
$g(2,1) = mex({g(1,1), g(0,1), g(2,0)}) = mex({0,1,2}) = 3$

3. XORで勝敗判定  
不偏ゲームを分割し、部分不偏ゲームとする。ここで「スプレイグ・グランディの定理」を用いると、**これらの部分不偏ゲームに対する全てのGrundy数に対してXORを取ったときの値が≠0ならば後手必勝、=0なら先手必勝**となる。  
Nimであれば、N個の山がある時は「1個の山についてのNim」という部分Nimを考えて、部分NimをN個並行して行うと考えることができる。N個の部分NimのGrundy数を求め、それらのXORを取ることで先手必勝か後手必勝かを判別できる。


<a id="Data"></a>
# データ構造